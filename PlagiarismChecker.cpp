


//
//FATIMA ISHTIAQ
//23i-0696
//Section E 
//





#include <iostream>
#include <fstream>
#include <cmath>

using namespace std;
const int MAX_WORDS = 1001;
const int MAX_LINE_LENGTH = 1000;

// Global Classes and Variables
// Use of classes is must 
class fileStorage {
private:
    int numOfDoc;
    bool WordsLimit;
public:
    char stopWordsList[MAX_WORDS][MAX_LINE_LENGTH];
    char** DocumentContent;
    char** UniqueWords;
    int UniqueCount;
    int** DocumentFrequency;
    fileStorage() {
        numOfDoc = 0;
        WordsLimit = true;
        UniqueCount = 0;
    }
    void setNumOfDoc(int a) { 
    numOfDoc = a; 
    DocumentContent = new char* [a+1];
    for (int i = 0; i < a+1; ++i) {
        DocumentContent[i] = new char[10000];
    }
    }
    int getNumOfDoc() { return numOfDoc; }
    void setWordsLimit(bool a) { WordsLimit = a; }
    char getDocumentContent(int i, int j) { return DocumentContent[i][j]; }
    void printStopWordsList() {
        int j = 0;
        for (int i = 0; i < MAX_WORDS;) {
            
            if (stopWordsList[i][j] == '\0') {
                i++;
                j = 0;
            }
            if (stopWordsList[i][0] != '#') {
                j++;
            }
            else {
                break;
            }
            
        }
    }
    void assignPathOfDocuments(int a) {
        //pathOfDocuments = new string[a];
    }
    void setPathOfDocuments(string s, int a) {
        //pathOfDocuments[a] = s;
    }
    void setLetterInStopWordsList(int i, int j, char ch) {
        if (WordsLimit) {
            if (j < MAX_LINE_LENGTH) {
                stopWordsList[i][j] = ch;
            }
            else {
                cout << "CAN NOT ADD MORE LETTERS TO THIS LINE" << endl;
            }
        }
    }
    void setLetterInDocumentContent(int i, int j, char ch) {
        if (WordsLimit) {
            if (j < MAX_LINE_LENGTH) {
                DocumentContent[i][j] = ch;
            }
            else {
                cout << "CAN NOT ADD MORE LETTERS TO THIS LINE" << endl;
            }
        }
    }
    char* getDocumentContent(int i) {
        if (i >= 0 && i < numOfDoc) {
            return DocumentContent[i];
        }
        return nullptr;
    }
}filestorage;;

//This Function is generated by GPT
bool isFileEmpty(ifstream& file) {
    bool check = (file.peek() == ifstream::traits_type::eof());
    return check;
}


// Function to read input from a file
void readInput(const char* pathofInputFile) {
    
    ifstream file(pathofInputFile);
    if (isFileEmpty(file)) {
        cout << "The file is empty." << std::endl;
        filestorage.setNumOfDoc(0);
        return;
    }
    /*if (!file.is_open()) {
        cout << "Error opening file" << endl;
        return;
    }*/
    bool check = false;
    char ch;
    int i = 0;
    int j = 0;
    while (file.get(ch)) {
        if (ch == ':') {
            file.get(ch);
            file.get(ch);
            check = true;
        }
        if (check) {
            while (ch != '\n') {
                if (ch == ' ') {
                    filestorage.setLetterInStopWordsList(i, j, '\0');
                    i++;
                    if (i > MAX_WORDS) {
                        cout << "MAX WORD LIMIT REACHED" << endl;
                        filestorage.setWordsLimit(false);
                    }
                    j = 0;
                    do {
                        file.get(ch);
                    } while (ch == ' ');
                }
                else {
                    filestorage.setLetterInStopWordsList(i, j, ch);
                    file.get(ch);
                    j++;
                }
            }
            file.get(ch);
            filestorage.setNumOfDoc(ch - '0');
            filestorage.assignPathOfDocuments(ch - '0');
            break;
        }
        
    }
    i++;
    filestorage.setLetterInStopWordsList(i, 0, '#');
    file.close();
    file.open(pathofInputFile);

    string pathForDocument;
    int docCount = 0;
    int counter = 0;
    getline(file,pathForDocument);
    getline(file, pathForDocument);
    char c;
    ifstream file1;
    while (getline(file, pathForDocument)) {
        if (pathForDocument.empty()) continue;

        file1.open(pathForDocument);

        if (!file1.is_open()) {
            cout << "Error opening document file: " << pathForDocument << endl;
            continue;
        }

        while (file1.get(c)) {
            filestorage.setLetterInDocumentContent(docCount, counter++, c);
            cout << c << endl;
        }
        filestorage.setLetterInDocumentContent(docCount, counter++, '\0');
        file1.close();

        docCount++;
        counter = 0;
    }
    file.close();

}

int getNumberOfDocument() { return filestorage.getNumOfDoc(); }

char* getText(int documentNumber) {
    return filestorage.getDocumentContent(documentNumber-1);
}

// Function to remove punctuation marks from documents
void removePunctuationMarks() {
    for (int i = 0; i < filestorage.getNumOfDoc(); ++i) {
        int j = 0;
        while (filestorage.DocumentContent[i][j] != '\0') {
            cout << filestorage.DocumentContent[i][j++];
            j++;
        }
        cout << endl;
    }
    int k = 0;
    char ch;

    for (int i = 0; i < filestorage.getNumOfDoc(); i++) {
        for (int j = 0; filestorage.getDocumentContent(i, j) != '\0'; j++) {
            if (filestorage.getDocumentContent(i, j) == ' ') {
                ch = filestorage.getDocumentContent(i, j);
                filestorage.setLetterInDocumentContent(i, k++, ch);
                do {
                    j++;
                } while (!((filestorage.getDocumentContent(i, j) >= 'A' && filestorage.getDocumentContent(i, j) <= 'Z') || (filestorage.getDocumentContent(i, j) >= 'a' && filestorage.getDocumentContent(i, j) <= 'z')));
            }
            if ((filestorage.getDocumentContent(i, j) >= 'A' && filestorage.getDocumentContent(i, j) <= 'Z') || (filestorage.getDocumentContent(i, j) >= 'a' && filestorage.getDocumentContent(i, j) <= 'z')) {
                
                    ch = filestorage.getDocumentContent(i, j);
                    filestorage.setLetterInDocumentContent(i, k++, ch);
            }
        }
        filestorage.setLetterInDocumentContent(i, k++, '\0');
        k = 0;
    }

}
// Function to convert all characters in documents to lowercase
void convertUpperToLowerCase() {
    int j = 0;
    char ch;
    ch = ' ';
    for (int i = 0; i < filestorage.getNumOfDoc(); ++i) {
        j = 0;
        ch = ' ';
        while ((ch = filestorage.getDocumentContent(i, j)) != '\0') {
            if (ch >= 'A' && ch <= 'Z') {
                ch = ch + 32;
            }

            filestorage.setLetterInDocumentContent(i, j, ch);
            j++;
        }
    }
    for (int i = 0; i < filestorage.getNumOfDoc(); ++i) {
        int j = 0;
        while (filestorage.DocumentContent[i][j] != '\0') {
            cout << filestorage.DocumentContent[i][j++];
        }
        cout << endl;
    }

}

void removeStopWords() {
    char tempstoreforDW[MAX_LINE_LENGTH];
    string stopWords[MAX_LINE_LENGTH];
    int stopWordCount = 0;

    int k = 0;
    char tempstoreforSW[MAX_LINE_LENGTH];
    for (int i = 0; filestorage.stopWordsList[i][0] != '#'; i+=1) {
        k = 0;
        for (int j = 0; filestorage.stopWordsList[i][j] != '\0'; j++) {
            
                tempstoreforSW[k++] = filestorage.stopWordsList[i][j];
        }
            tempstoreforSW[k] = '\0';
            stopWords[stopWordCount++] = tempstoreforSW;
            k = 0;
    }
    int DI;
    DI = 0;
    int TDI;
    TDI = 0;
    bool check;
    bool check2;
    char* document = nullptr;
    string currentWord;
    currentWord = "";
    int loop = 0;
    int loop2 = 0;
    int count = 0;
    for (; DI < filestorage.getNumOfDoc(); DI++) {
        TDI = 0;
        document = filestorage.getDocumentContent(DI);
        TDI = 0;
        currentWord = "";
        check = false;
        for (int i = 0; document[i] != '\0'; i+=1) {
            char c = document[i];
            if (c!=' ') {
                currentWord += c;
            }
            else {
                if ((currentWord == "")) {
                    count++;
                }
                else {
                    for (int k = 0; k <= stopWordCount - 1; k += 1) {
                        if (stopWords[k] == currentWord) {
                            check = true;
                            break;
                        }
                    }
                    if (check) {
                        loop++;
                    }
                    else {
                        for (int k = 0; k <= currentWord.length() - 1; k += 1) {
                            tempstoreforDW[TDI++] = currentWord[k];
                        }
                        tempstoreforDW[TDI++] = ' ';
                    }
                    currentWord = "";
                }
            }
            check = false;
        }

        check2 = false;
        if ((currentWord == "")) {
            loop2++;
        }
        else {
            check2 = false;
            for (int k = 0; k < stopWordCount; k += 1) {
                if (stopWords[k] == currentWord) {
                    check2 = true;
                    break;
                }
            }
            if (check2 == true) {

            }
            else {
                for (int k = 0; k <= currentWord.length() - 1; k += 1) {
                    tempstoreforDW[TDI++] = currentWord[k];
                }
                tempstoreforDW[TDI++] = ' ';
            }
        }
        cout << loop << endl;
        cout << loop2 << endl;
        check2 = false;
        k = 0;
        tempstoreforDW[TDI] = '\0';

        for (int i = 0; i <= TDI; i++) {
            filestorage.setLetterInDocumentContent(DI, i, tempstoreforDW[i]);
            if (tempstoreforDW[i] == '\0') {
                filestorage.setLetterInDocumentContent(DI, i-1, tempstoreforDW[i]);
            }
        }
        filestorage.setLetterInDocumentContent(DI, TDI + 1, '\0');
        check = false;
        k = 0;
    }
    check2 = false;
    k = 0;

    for (int i = 0; i < filestorage.getNumOfDoc(); ++i) {
        int j = 0;
        while (filestorage.DocumentContent[i][j] != '\0') {
            cout << filestorage.DocumentContent[i][j++];
        }
        cout << endl;
    }
}

int myStrCmp(const char* str1, const char* str2) {
    int i;
    i = 0;
    int pass = 0;
    while (str1[i]!='\0' && str2[i]!='\0') {
        if (str1[i] != str2[i]) {
            pass = 1;
            return pass;
        }
        i++;
        pass = 0;
    }
    return pass;
}


void myStrCpy(char* dest, const char* src) {
    int i = 0;
    for (; src[i] != '\0'; i++) {
        dest[i] = src[i];
    }
   
    dest[i] = '\0';  // Null-terminate the destination string
}


// Function to generate frequencies of each unique word in each document
void generateFrequencies(char**& uniqueWords, int& uniqueCount, int**& documentFrequency) {
    uniqueCount = 0;
    char temp[MAX_LINE_LENGTH];
    bool check;
    check = false;
    filestorage.UniqueWords = nullptr;
    filestorage.UniqueCount = 0;
    filestorage.DocumentFrequency = 0;

    uniqueWords = new char* [MAX_WORDS];
    for (int i = 0; i < MAX_WORDS; i+=1) {
        uniqueWords[i] = new char[MAX_LINE_LENGTH];
    }

    documentFrequency = new int* [filestorage.getNumOfDoc()];
    for (int i = 0; i <= filestorage.getNumOfDoc()-1; i+=1) {
        documentFrequency[i] = new int[MAX_WORDS]();
    }
    int DI = 0;
    int start;
    int end;
    int WI;
    char* document = nullptr;
    int length = 0;
    int loop3 = 0;
    int loop = 0;
    bool Check;
    for (; DI <= filestorage.getNumOfDoc()-1; DI++) {
        check = false;
        document = filestorage.getDocumentContent(DI);
        start = 0;
        end = 0;
        length = 0;
        filestorage.UniqueWords = nullptr;
        filestorage.UniqueCount = 0;
        filestorage.DocumentFrequency = 0;

        while (document[start] != '\0') {
            if (document[start] == ' ') {
                start++;
            }
            end = start;

            while ((document[end] != '\0') && (document[end] != ' ') ) {
                end++;
            }
            length = 0;
            length = end - start;
            for (int i = 0; i <= length-1; i+=1) {
                temp[i] = document[start + i];
            }
            temp[length] = '\0';

            check = false;
            WI = 0;
            for (WI = 0; WI < uniqueCount; WI++) {
                Check = myStrCmp(uniqueWords[WI], temp) == 0;
                if (Check) {
                    check = true;
                    break;
                }
            }

            if (check) {
                loop3++;
            }
            else {
                myStrCpy(uniqueWords[uniqueCount], temp);
                uniqueCount++;
                loop++;
                cout << loop << endl;
            }
            Check = WI <= uniqueCount - 1;
            if (Check) {
                documentFrequency[DI][WI]++;
            }

            start = end;
        }
        filestorage.UniqueWords = nullptr;
        filestorage.UniqueCount = 0;
        filestorage.DocumentFrequency = 0;

    }
    filestorage.UniqueWords = nullptr;
    filestorage.UniqueCount = 0;
    filestorage.DocumentFrequency = 0;

    filestorage.UniqueWords = uniqueWords;
    filestorage.UniqueCount = uniqueCount;
    filestorage.DocumentFrequency = documentFrequency;
}

// -1 if not found 
int getFrequency(char* word, int documentNum) {
    int count = 0;
    bool check = (documentNum <= 0 || documentNum > filestorage.getNumOfDoc());
    bool check2;
    if (check) {
        return -1;
    }
    else {
        count++;
        cout << count << endl;
    }
    check2 = false;
    for (int i = 0; i <= filestorage.UniqueCount-1; i+=1) {
        check2 = myStrCmp(word, filestorage.UniqueWords[i]) == 0;
        if (check2==true) {
            return filestorage.DocumentFrequency[documentNum - 1][i];
        }
    }
    return -1;
}

// Function to calculate all cosine similarities between documents
void calculateAllCosineSimilarities(double**& similarities, int** documentFrequency) {
    similarities = new double* [filestorage.getNumOfDoc()];
    for (int i = 0; i <= filestorage.getNumOfDoc()-1; i+=1) {
        similarities[i] = new double[filestorage.getNumOfDoc()];
        for (int j = 0; j <= filestorage.getNumOfDoc()-1; j+=1) {
            similarities[i][j] = 0;
        }
    }

    double temp;
    double DP=0;
    double MI =0;
    double MJ =0;
    double ans1 = 0;
    double ans2 = 0;
    double ans3 = 0;
    for (int i = 0; i < filestorage.getNumOfDoc(); i+=1) {
        for (int j = i; j < filestorage.getNumOfDoc(); j+=1) { 
           
            for (int k = 0; k < filestorage.UniqueCount; ) {
                temp = documentFrequency[i][k] * documentFrequency[j][k];
                DP += temp;
                k++;
                temp = 0;
            }

            for (int k = 0; k < filestorage.UniqueCount; ) {
                MI += documentFrequency[i][k] * documentFrequency[i][k];
                MJ += documentFrequency[j][k] * documentFrequency[j][k];
                k++;
            }
            ans1 = sqrt(MI);
            ans2 = sqrt(MJ);
            ans3 = DP / (ans1 * ans2);

            similarities[i][j] = ans3;
        }
        ans1 = 0;
        ans2 = 0;
        ans3 = 0;
        DP = 0;
        MI = 0;
        MJ = 0;
        temp = 0;
        
    }
    ans1 = 0;
    ans2 = 0;
    ans3 = 0;
    DP = 0;
    MI = 0;
    MJ = 0;
    temp = 0;
}


double similarityIn(int documentNum1, int documentNum2) {
    if (documentNum1 <= 0 || documentNum2 <= 0) {
        cout << "Invalid" << endl;
        return -1;
    }
    if (documentNum1 == documentNum2) {
        return 100;
    }
    
    documentNum1--;
    documentNum2--;
    double DP = 0;
    double M1 = 0;
    double M2 = 0;
    double ans1;
    double ans2;
    double percentage;
    for (int i = 0; i <= filestorage.UniqueCount-1; i+=1) {
        M1 += (pow(filestorage.DocumentFrequency[documentNum1][i], 2));
        M2 += (pow(filestorage.DocumentFrequency[documentNum2][i], 2));
        DP += (filestorage.DocumentFrequency[documentNum1][i] * filestorage.DocumentFrequency[documentNum2][i]);
    }
    ans1 = 0;
    ans2 = 0;
    ans1 = sqrt(M1);
    ans2 = sqrt(M2);
    percentage = 0;
    percentage = (DP / (sqrt(M1) * sqrt(M2)))*100;

    return percentage; 
}
